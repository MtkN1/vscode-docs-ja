---
Order: 116
TOCTitle: November 2025
PageTitle: Visual Studio Code November 2025
MetaDescription: What's new in the Visual Studio Code November 2025 Release (1.107).
MetaSocialImage: 1_107/release-highlights-stable.webp
Date: 2025-12-10
DownloadVersion: 1.107.1
---
# 2025 年 11 月 (バージョン 1.107) {: #november-2025-version-1107 }

_リリース日: 2025 年 12 月 10 日_

**Update 1.107.1**: このアップデートでは、[エージェントセッションエクスペリエンス](#integrating-agent-sessions-and-chat) が改善され、[エージェントワークフローチュートリアル](https://code.visualstudio.com/docs/copilot/agents/agents-tutorial) が追加され、いくつかの [問題](https://github.com/microsoft/vscode/issues?q=is%3Aissue+is%3Aclosed+milestone%3A%22November+2025+Recovery+1%22+) が修正されました。主なハイライトは以下の通りです:

* エージェントセッションビューがデフォルトでサイドバイサイドになり、トグル状態が記憶されるようになりました。
* 入力が必要なエージェントセッションが明確にマークされるようになりました。
* バックグラウンドセッションを作成する際にワークスペースの変更をコピーする機能がサポートされました。
* 新しいセッションを作成してもチャットプロンプトがクリアされなくなりました。
* クラウドセッションでのツール呼び出しがデフォルトで折りたたまれるようになりました。

<!-- DOWNLOAD_LINKS_PLACEHOLDER -->

---

VS Code 1.107 では、マルチエージェントオーケストレーションが導入されました。GitHub Copilot とカスタムエージェントを併用して、開発を加速および並列化できます。

* **Agent HQ** は、すべてのエージェントを管理するための単一の場所を提供し、Copilot とカスタムエージェントがタスク全体で連携できるようにします。
* **Background agents** は、アクティブな作業を妨げないように分離されたワークスペースで実行され、複数のバックグラウンドタスクを同時に有効にします。
* **Delegate** ローカル、バックグラウンド、またはクラウドエージェント間で作業を委任し、中断することなくワークフローを維持します。

![VS Code 2025年11月リリース画像。](https://code.visualstudio.com/assets/updates/1_107/release-highlights-stable.webp)

<br>

エンジニアによるこれらの機能の紹介については、[VS Code 1.107 リリースハイライトビデオ](https://aka.ms/VSCode/1-107rn) をご覧ください！

ハッピーコーディング！

<br>

>これらのリリースノートは、[code.visualstudio.com](https://code.visualstudio.com) の [Updates](https://code.visualstudio.com/updates) でオンラインで読むことができます。<br>
>**Insiders:** [Insiders ビルドのナイトリービルドをダウンロード](https://code.visualstudio.com/insiders) して、最新のアップデートが利用可能になり次第お試しください。<br>

---

<!-- TOC
<div class="toc-nav-layout">
  <nav id="toc-nav">
    <div>このアップデートについて</div>
    <ul>
      <li><a href="#agents">エージェント</a></li>
      <li><a href="#chat">チャット</a></li>
      <li><a href="#mcp">MCP</a></li>
      <li><a href="#accessibility">アクセシビリティ</a></li>
      <li><a href="#editor-experience">エディターのエクスペリエンス</a></li>
      <li><a href="#code-editing">コード編集</a></li>
      <li><a href="#source-control">ソース管理</a></li>
      <li><a href="#debugging">デバッグ</a></li>
      <li><a href="#terminal">ターミナル</a></li>
      <li><a href="#authentication">認証</a></li>
      <li><a href="#languages">言語</a></li>
      <li><a href="#remote-development">リモート開発</a></li>
      <li><a href="#enterprise">エンタープライズ</a></li>
      <li><a href="#contributions-to-extensions">拡張機能への貢献</a></li>
      <li><a href="#proposed-apis">提案された API</a></li>
      <li><a href="#engineering">エンジニアリング</a></li>
      <li><a href="#notable-fixes">注目すべき修正</a></li>
      <li><a href="#thank-you">ありがとう</a></li>
    </ul>
  </nav>
  <div class="notes-main">
Navigation End -->

## エージェント {: #agents }

* チャットからエージェントを管理 ([詳細](#integrating-agent-sessions-and-chat))。
* 組織全体でエージェントを共有 ([詳細](#share-custom-agents-across-your-github-organization-experimental))。
* チャットが閉じている間もエージェントをアクティブに維持 ([詳細](#local-agent-sessions-remain-active-when-closed))。
* エージェントセッションをローカルからクラウドへ移動 ([詳細](#continue-tasks-in-background-or-cloud-agents))。
* 専用の Git ワークツリーでエージェントを実行 ([詳細](#isolate-background-agents-with-git-worktrees))。
* バックグラウンドエージェントにコンテキストを添付 ([詳細](#adding-context-to-background-agents))。
* バックグラウンドエージェントをカスタマイズ ([詳細](#use-custom-agents-with-background-agents-experimental))。
* 環境全体でカスタムエージェントを再利用 ([詳細](#agent-tooling-reorganization))。
* カスタムサブエージェントを実行 ([詳細](#run-agents-as-subagents-experimental))。
* Claude スキルを再利用 ([詳細](#reuse-your-claude-skills-experimental))。

### エージェントセッションとチャットの統合 {: #integrating-agent-sessions-and-chat }

**Setting**: `setting(chat.viewSessions.enabled)`

**Update 1.107.1**: このアップデートでは、サイドバイサイドセッションエクスペリエンスが大幅に改善されました。トグルでセッションを非表示にすると、その選択が記憶され、チャットビューのサイズを自由に調整できるようになりました。[エージェントワークフローチュートリアル](https://code.visualstudio.com/docs/copilot/agents/agents-tutorial) で始めましょう。

エージェントは、ユーザーに代わってコーディングタスクを自律的に実行するための鍵となります。チャットインターフェイスは、VS Code 内でローカルに実行されているか、CLI を使用してバックグラウンドで実行されているか、クラウドで実行されているか、サードパーティの拡張機能から実行されているかに関係なく、エージェントと対話するための主要な方法です。詳細については、ドキュメントの [VS Code でのエージェントの使用](https://code.visualstudio.com/docs/copilot/agents/overview) を参照してください。

このイテレーションでは、エージェントセッションをチャットビューに統合し、エージェントを使用する際の統一されたエクスペリエンスを提供しました。一目で、セッションのステータス、進行状況、ファイル変更の統計を確認できます。セッションをアーカイブまたはアーカイブ解除して、セッションリストを管理しやすくすることができます。

<video src="https://code.visualstudio.com/assets/updates/1_107/agent-sessions.mp4" title="チャットビューでのエージェントセッションの使用を示すビデオ。" autoplay loop controls muted></video>

ワークスペースで作業している場合、セッションリストには現在のワークスペースに関連するセッションのみが表示されます。空のウィンドウにいる場合は、ワークスペース全体のすべてのセッションが表示されます。

リストからセッションを選択すると、サイドバーのチャットビューでセッションが開き、完全な会話履歴を確認できます。必要に応じて、セッションをエディタータブまたは新しいウィンドウとして開くこともできます。セッションを右クリックすると、これらのオプションを含むコンテキストメニューが表示されます。

![セッションリスト内のセッションのコンテキストメニューを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/sessions-context.png)

`setting(chat.viewSessions.enabled)` を構成することで、チャットビューのセッションリストを無効にすることができます。

この変更の結果として、スタンドアロンの **Agent Sessions** ビューをデフォルトで無効にしています。スタンドアロンビューを引き続き使用したい場合は、`setting(chat.agentSessionsViewLocation)` を介して再度有効にすることができます。将来のリリースでは、スタンドアロンビューを完全に削除する予定です。

#### コンパクトビュー {: #compact-view }

チャットビューが狭い場合、新しいチャットセッションを開始すると、セッションのリストがチャットビュー内に表示されます。デフォルトでは、リストにはアーカイブされていない最新の 3 つのセッションが表示されます。

![チャットビューの最近のセッションを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/recent-sessions.png)

**Show All Sessions** を選択すると、検索とフィルターのオプションを含むセッションの完全なリストが表示されます。

![チャットビューのすべてのセッションを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/recent-sessions-all.png)

アクションを使用してエージェントセッションサイドバーを切り替え、すべてのセッションをより広く表示することができます。

#### サイドバイサイドビュー {: #sidebyside-view }

チャットビューが十分に広い場合 (たとえば、最大化したとき)、エージェントセッションのリストは自動的にチャットビューと並べて表示されます。このビューでは、コンテキストを失うことなくセッション間をすばやく移動できます。対応するコントロールを使用して、このサイドバイサイドビューを手動で切り替えることもできます。

![チャットビューと並んで表示されるすべてのセッションを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/all-sessions.png)

セッションリストを制限するには、プロバイダーまたは状態でセッションをフィルター処理できます。VS Code はこのフィルターを保持します。

#### 向きの設定 {: #orientation-setting }

**Setting**: `setting(chat.viewSessions.orientation)`

デフォルトでは、セッションリストは、幅が十分にある場合、または手動でセッションリストを切り替えた場合に、チャットビューと並べて表示されます。`setting(chat.viewSessions.orientation)` 設定でこの動作を変更できます。

* `auto` (デフォルト): 幅が許せばセッションを並べて表示し、それ以外の場合は空のチャットの上に表示します
* `stacked`: 常に空のチャットの上にセッションを表示します
* `sideBySide`: 幅が許せばセッションリストを並べて表示し、それ以外の場合はセッションリストを非表示にします

### ローカルエージェントセッションは閉じてもアクティブなまま {: #local-agent-sessions-remain-active-when-closed }

以前は、ローカルチャットセッションを閉じると、実行中のエージェントリクエストがキャンセルされていました。これにより、長時間実行されるタスクや複数のタスクを同時に実行する場合のローカルエージェントの有用性が制限されていました。

現在、ローカルエージェントは、チャットエディターやチャットビューで開いていなくても、バックグラウンドで実行され続けます。セッションリストで実行中のエージェントのステータスを確認でき、いつでもセッションに戻って詳細な進行状況を確認できます。

<video src="https://code.visualstudio.com/assets/updates/1_107/local-agent-active-when-closed.mp4" title="バックグラウンドで実行されているローカルエージェントを示すビデオ。" autoplay loop controls muted></video>

詳細については、[チャットでのローカルエージェントの使用](https://code.visualstudio.com/docs/copilot/chat/copilot-chat#_switch-between-agents) を参照してください。

### バックグラウンドまたはクラウドエージェントでタスクを継続 {: #continue-tasks-in-background-or-cloud-agents }

ローカルエージェントは、VS Code 内でエージェントとやり取りできるインタラクティブなセッションに最適です。これは、ブレインストーミング、探索的タスクの実行、または実装計画の作成に役立ちます。明確な計画ができたら、タスクをバックグラウンドまたはクラウドエージェントに引き継いで自律的に実行させることができます。

このイテレーションでは、ローカルチャットをバックグラウンドまたはクラウドエージェントで継続するエクスペリエンスを改善しました。UI 全体で、新しい **Continue in** オプションを使用してタスクをシームレスに継続できるようになりました。

ローカルチャットをバックグラウンドまたはクラウドエージェントに継続すると、現在のチャットコンテキストが引き継がれ、元のセッションはハンドオフ後にアーカイブされます。

* チャットビュー:

    ![チャットビューの 'Continue in' ボタンを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/continue-in-chatwidget.png)

* プランエージェント:

    ![プランエージェントを使用しているときの 'Start implementation' ボタンを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/continue-in-planmode.png)

* 無題のプロンプトファイル:

    ![無題のプロンプトファイルの 'Continue in' ボタンを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/continue-in-promptfile.png)

### Git ワークツリーによるバックグラウンドエージェントの分離 {: #isolate-background-agents-with-git-worktrees }

バックグラウンドエージェント (以前は CLIエージェントと呼ばれていました) は、バックグラウンドで自律的に実行されるように設計されており、他の作業に集中している間にタスクをオフロードできます。複数のバックグラウンドエージェントを同時に実行すると、ワークスペース内の同じファイルを変更する場合に競合が発生する可能性があります。

このイテレーションでは、[Git ワークツリー](https://code.visualstudio.com/docs/sourcecontrol/branches-worktrees#_working-with-git-worktrees) のサポートを導入することで、バックグラウンドエージェントの分離を強化しました。新しいバックグラウンドエージェントを作成するときに、現在のワークスペースで実行するか、専用の Git ワークツリーで実行するかを選択できます。

![バックグラウンドエージェントを作成するときの Git ワークツリー ドロップダウンを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/background_worktree.png)

ワークツリーでバックグラウンドエージェントを実行すると、エージェントはセッション用に新しい Git ワークツリーを自動的に作成し、変更を別のフォルダーに分離します。これにより、競合することなく複数のバックグラウンドエージェントを同時に実行できます。

エージェントがタスクを完了したら、ワークツリー内のバックグラウンドエージェントによる変更を簡単に確認してメインワークスペースにマージできます。また、ワークツリーからの変更をワークスペースに直接適用する新しいアクションも追加しました。

![ワークツリーで発生したファイル変更を示すバックグラウンドエージェントのスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/filechanges.png)

詳細については、[VS Code でのバックグラウンドエージェントの使用](https://code.visualstudio.com/docs/copilot/agents/background-agents) を参照してください。

### バックグラウンドエージェントへのコンテキストの追加 {: #adding-context-to-background-agents }

バックグラウンドエージェントは、複数のコンテキスト添付タイプをサポートするようになりました。選択範囲、問題、シンボル、検索結果、git コミットなどを任意のプロンプトに添付できます。これにより、よりリッチで正確なプロンプトを作成し、より複雑で柔軟なワークフローを実現できます。たとえば、報告された問題を添付し、ファイルパスや行番号を手動で指定せずにエージェントに修正を依頼できます。

![シンボルとエラーがコンテキストとして添付されたバックグラウンドエージェントセッションのスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/background_attachments.png)

### GitHub 組織全体でのカスタムエージェントの共有 (実験的) {: #share-custom-agents-across-your-github-organization-experimental }

**Setting**: `setting(github.copilot.chat.customAgents.showOrganizationAndEnterpriseAgents)`

以前は、カスタムエージェントはワークスペースまたはユーザーレベルでのみ定義できました。組織全体でカスタムエージェントを共有したい場合は、エージェントファイルを各ユーザーに手動で配布する必要がありました。

このリリースでは、GitHub アカウントの組織レベルでカスタムエージェントを定義できるようになりました。この実験的な機能により、チャットで個人用エージェントと一緒に組織固有のエージェントを使用できます。

この機能を有効にするには、`setting(github.copilot.chat.customAgents.showOrganizationAndEnterpriseAgents)` を `true` に設定します。有効にすると、組織によって作成されたカスタムエージェントが VS Code のエージェントドロップダウンに表示されます。

組織向けのカスタムエージェントの作成の詳細については、GitHub ドキュメントの [カスタムエージェントの作成](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/create-custom-agents) を参照してください。

### バックグラウンドエージェントでのカスタムエージェントの使用 (実験的) {: #use-custom-agents-with-background-agents-experimental }

**Setting**: `setting(github.copilot.chat.cli.customAgents.enabled)`

独自のカスタムエージェントをバックグラウンドエージェントに取り込むことができるようになりました。有効にすると、`.github/agents` フォルダーで定義されたカスタムエージェントがエージェントリストに表示され、ワークフローや要件に合わせて調整されたエージェントを活用できます。

この実験的な機能は、`setting(github.copilot.chat.cli.customAgents.enabled)` 設定で有効にできます。

![エージェントドロップダウンリストにカスタムプランナーエージェントがあるバックグラウンドエージェントセッションを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/background_agents.png)

詳細については、ドキュメントの [カスタムエージェントの定義](https://code.visualstudio.com/docs/copilot/customization/custom-agents) を参照してください。

### エージェントツールの再編成 {: #agent-tooling-reorganization }

GitHub カスタムエージェントとの互換性を向上させるために、エージェントツール構造を再編成しました。これにより、個別の構成を必要とせずに、VS Code と GitHub 環境全体でカスタムエージェントをより簡単に再利用できます。

この変更の一環として、特定の既存のツール参照とそれらが属するツールセットの名前を変更しました。エージェントファイル内の既存のツール参照は引き続き機能しますが、最新の推奨形式に名前を変更するためのコードアクションが表示されます。これにより、エージェント構成が現在のベストプラクティスに従い、プラットフォーム間での互換性が維持されます。

### エージェントをサブエージェントとして実行 (実験的) {: #run-agents-as-subagents-experimental }

**Setting**: `setting(chat.customAgentInSubagent.enabled)`

エージェントが複雑な問題を解決する必要がある場合、タスクを [サブエージェント](https://code.visualstudio.com/docs/copilot/chat/chat-sessions#_contextisolated-subagents) に委任できます。サブエージェントはメインチャットセッションから独立して動作し、独自のコンテキストウィンドウを持ちます。これにより、メインの会話が高レベルの目的に集中し続け、コンテキストウィンドウの制限を管理するのに役立ちます。

このリリースでは、[カスタムエージェント](https://code.visualstudio.com/docs/copilot/customization/custom-agents) を介してサブエージェントをカスタマイズできます。カスタムエージェントを使用すると、AI の特定のペルソナを定義し、特定のタスクやドメインに合わせて動作を調整できます。たとえば、コードレビュー担当者エージェントは、コードを変更するのではなく、コードのレビューに重点を置きます。

カスタムエージェントをサブエージェントとして使用するには、次の手順に従います:

1. `setting(chat.customAgentInSubagent.enabled)` を有効にします

1. まだ持っていない場合は、**Chat: New Custom Agent** コマンドを使用してカスタムエージェントを作成します。

1. チャットで、モデルに「what subagents can you use?」と尋ねて、利用可能なサブエージェントのリストを確認します。カスタムエージェントがリストに表示されるはずです。

1. カスタムエージェントの要件を満たすプロンプトを入力します。言語モデルは、カスタムエージェントの説明と引数を使用して、リクエストに使用する必要があるかどうかを判断します。

    ![カスタムエージェントをサブエージェントとして使用するチャット会話のスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/use-agents-as-subagents.png)

カスタムエージェントがサブエージェントとして使用されないようにするには、`*.agent.md` ファイルのメタデータプロパティ `infer` を `false` に設定します。

詳細については、[チャットでのサブエージェントの使用](https://code.visualstudio.com/docs/copilot/chat/chat-sessions#_contextisolated-subagents) を参照してください。

### Claude スキルの再利用 (実験的) {: #reuse-your-claude-skills-experimental }

**Setting**: `setting(chat.useClaudeSkills)`

スキルは [Claude Code](https://code.claude.com/docs/en/skills) によって導入されたもので、エージェントがオンデマンドでロードできる機能です。各スキルには、スキルを宣伝する短い説明が付いています。有用な場合、エージェントは完全なスキルの指示を読むことを決定できます。スキルの指示には、スクリプトやテンプレートなどのサポートファイルを含めることができます。
ロードされると、スキルの指示とサポートファイルはメインの会話のコンテキストの一部になります。

VS Code は既存のスキルを再利用できるようになりました。`setting(chat.useClaudeSkills)` 設定を有効にして、エージェントがスキルを発見して使用できるようにします。

![VS Code のチャットで Claude スキルを再利用している様子を示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/use-claude-skills.png)

VS Code は、`~/.claude/skills/skill-name/SKILL.md` にある個人用スキルと、`${workspaceFolder}.claude/skills/skill-name/SKILL.md` にあるワークスペースフォルダー内のプロジェクトスキルをサポートしています。

`SKILL.md` ファイルのヘッダーに、スキルを宣伝する `description` 属性があることを確認してください。VS Code では `allowed-tools` 属性はサポートされていないことに注意してください。

エージェントモードでは、read-file ツールが有効になっていることを確認し、「What skills do you have」と尋ねてスキルが見つかるかどうかを確認します。次に、スキルで回答できるリクエストを行います。エージェントがスキルを使用しない場合は、スキルの説明を改善するか、モデルにスキルを使用するように促します。

## チャット {: #chat }

* インラインチャットがコード編集用に最適化されました ([詳細](#inline-chat-ux))。
* チャットモデルを管理 ([詳細](#language-models-editor))。
* 外部 Web コンテンツを確認 ([詳細](#url-and-domain-auto-approval))。
* 動的 Web コンテンツを取得 ([詳細](#more-robust-fetch-tool))。
* 無視されたファイルを検索 ([詳細](#text-search-tool-can-search-ignored-files))。
* チャットでターミナル出力にアクセス ([詳細](#rich-terminal-output-in-chat))。
* セッションのターミナルコマンドを自動的に承認 ([詳細](#allow-all-terminal-commands-in-this-session))。
* より多くのキーボードショートカットが利用可能 ([詳細](#keyboard-shortcuts-for-chat-terminal-actions))。
* Azure ホストモデルに Entra ID を使用 ([詳細](#azure-model-provider-entra-id-as-the-default-authentication))。
* Anthropic モデルの拡張思考予算を構成 ([詳細](#anthropic-models-extended-thinking-support))。
* チャットをより効率的に使用 ([詳細](#chat-view-appearance-improvements))。
* 機密ファイルへの編集の差分を表示 ([詳細](#diffs-for-edits-to-sensitive-files))。
* 推論モデルのチャットツール呼び出しを非表示 ([詳細](#collapsible-reasoning-and-tools-output-experimental))。

### インラインチャットの UX {: #inline-chat-ux }

**Setting**: `setting(inlineChat.enableV2:true)`

インラインチャットエクスペリエンスを継続的に改善し、VS Code の他のチャットエクスペリエンスと整合させ、迅速な単一ファイルのコード変更に最適化しています。

<video src="https://code.visualstudio.com/assets/updates/1_107/inline_chat_edit.mp4" title="動作中のインラインチャットの更新された UX を示すビデオ。" autoplay loop controls muted></video>

以前は、一般的な質問や議論にもインラインチャットを使用できました。現在、インラインチャットは現在のファイル内のコード変更に最適化されています。インラインチャットで処理できないタスクの場合、自動的にチャットビューにアップグレードされ、同じモデルと同じコンテキストを使用してプロンプトが再生されます。

<video src="https://code.visualstudio.com/assets/updates/1_107/inline_chat_exit.mp4" title="インラインチャットからチャットビューへの終了フローを示すビデオ。" autoplay loop controls muted></video>
`setting(inlineChat.enableV2:true)` 設定 (プレビュー) は、拡張機能がプロンプトを処理する方法のみを制御するようになりました。これはまだ開発中ですが、安心してお試しいただけます。

### 言語モデルエディター {: #language-models-editor }

VS Code のチャットは、GitHub Copilot、サードパーティの拡張機能、または Bring Your Own Key (BYOK) プロバイダーを介して提供される複数の言語モデルをサポートしています。これらすべてのモデルを管理することは、特にさまざまなプロバイダーの多くのモデルにアクセスできる場合に困難になる可能性があります。詳細については、[VS Code での言語モデルの使用](https://code.visualstudio.com/docs/copilot/customization/language-models) を参照してください。

**Language Models** エディターは、VS Code のチャットで使用可能なすべての言語モデルを表示および管理するための一元化された場所を提供します。チャットのモデルピッカーから、またはコマンドパレットで **Chat: Manage Language Models** を使用して開くことができます。

<video src="https://code.visualstudio.com/assets/updates/1_107/language-models-editor.mp4" title="Language Models エディターを示すビデオ" autoplay loop controls muted></video>

エディターには、利用可能なすべてのモデルが一覧表示され、モデルの機能、コンテキストサイズ、請求の詳細、可視性ステータスなどの主要な情報が表示されます。デフォルトでは、モデルはプロバイダーごとにグループ化されていますが、可視性ごとにグループ化することもできます。

モデル名またはコンテキストサイズにカーソルを合わせると、モデルID、バージョン、ステータス、トークンの内訳などの詳細情報が表示されます。

以下を使用してモデルを検索およびフィルター処理できます:

* ハイライト付きのテキスト検索
* プロバイダー フィルター: `@provider:"OpenAI"`
* 機能 フィルター: `@capability:tools`, `@capability:vision`, `@capability:agent`
* 可視性 フィルター: `@visible:true/false`

#### モデルの可視性の管理 {: #manage-model-visibility }

利用可能なモデルが増えると、モデルピッカーが圧倒され、ナビゲートが難しくなる可能性があります。Language Models エディターでは、各モデルの可視性を切り替えて、モデルピッカーに表示されるモデルを制御できます。モデルにカーソルを合わせ、目のアイコンを選択して可視性を切り替えます。

#### インストール済みプロバイダーからのモデルの追加 {: #add-models-from-installed-providers }

Language Models エディターから、**Add Models...** を使用してさらにモデルを追加できます。これにより、インストールされているすべてのモデルプロバイダーのドロップダウンリストが表示されます。プロバイダーを選択して構成し、そのモデルを VS Code のチャットに追加します。

これにより、Language Models エディターから移動することなく、インストールした追加のモデルプロバイダーを簡単にアクティブ化できます。プロバイダー行の歯車アイコンを選択して、プロバイダー管理にアクセスします。

### URL とドメインの自動承認 {: #url-and-domain-auto-approval }

このイテレーションでは、フェッチツールの URL 自動承認のセキュリティとユーザーエクスペリエンスを強化しました。モデルが明示的に要求していない URL からコンテンツを取得することを決定すると、新しい 2 段階の承認エクスペリエンスが表示されます:

* **Approve the initial request to fetch the URL**

    このステップにより、連絡先のドメインを信頼し、信頼できないサイトに機密データが送信されるのを防ぐことができます。

    ![最初の取得リクエストを承認するための確認を示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/approve-fetch.png)

    1 回限りの承認、または特定の URL またはドメインへの将来のリクエストを自動的に承認するオプションがあります。

    事前承認は、["Trusted Domains" 機能](https://code.visualstudio.com/docs/editing/editingevolved#_outgoing-link-protection) を尊重します。ドメインがそこにリストされている場合、そのドメインへのリクエストを行うことが自動的に承認され、応答の確認ステップに延期されます。

* **Approve to use the fetched content in chat and follow-up tool calls**

    このステップにより、取得したコンテンツがチャットに追加されたり、他のツールに渡されたりする前に確認し、潜在的なプロンプトインジェクション攻撃を防ぐことができます。

    たとえば、GitHub.com などの有名なサイトからコンテンツを取得するリクエストを承認する場合があります。しかし、問題の説明やコメントなどのコンテンツはユーザー生成であるため、モデルの動作を操作する可能性のある有害なコンテンツが含まれている可能性があります。

詳細については、VS Code チャットの [URL とドメインの承認](https://code.visualstudio.com/docs/copilot/chat/chat-tools#url-approval) を参照してください。

### より堅牢なフェッチツール {: #more-robust-fetch-tool }

`#fetch` エージェントツールは、動的 Web コンテンツをより効果的に処理するようになりました。静的 HTML に加えて、動的コンテンツを取得できます。コンテンツをロードするために JavaScript に依存する Web サイト (シングルページアプリケーション (SPA)、最新のドキュメントサイト、Jira などの課題追跡システムなど) は、不完全または空の結果を返さなくなりました。

フェッチツールは、ページを取得する前に JavaScript が実行され、コンテンツがロードされるのを待機し、動的にレンダリングされたコンテンツがキャプチャされるようにします。この改善により、実際のシナリオでツールが大幅に便利になります。

`#fetch` の後に URL を使用すると、モデルは最初の HTML スケルトンだけでなく、ブラウザーで表示される実際のコンテンツにアクセスします。これは、Web ページについて質問したり、モデルにオンラインコンテンツの分析を依頼したりするときに、より正確で完全な情報を意味します。

### テキスト検索ツールで無視されたファイルを検索可能に {: #text-search-tool-can-search-ignored-files }

`#textSearch` ツールは、`files.exclude` または `search.exclude` 設定、または `node_modules` フォルダーなどの `.gitignore` ファイルで指定された無視されたファイル/フォルダー内の検索をサポートするようになりました。また、結果がない場合に無視されたファイル/フォルダーに関するヒントをエージェントに返し、エージェントがそれらの無視されたファイル/フォルダー内の検索を有効にできるようにします。

### チャットでのリッチなターミナル出力 {: #rich-terminal-output-in-chat }

**Run in Terminal** 応答で **Toggle Output** を使用すると、チャット内に完全な読み取り専用の `xterm.js` ターミナルで出力がレンダリングされるようになりました。このアプローチの優れた利点は、バッキングターミナルが終了した後でも VS Code がキャプチャされた出力を保持するため、いつでも以前の実行を再度開いて、コマンド実行時のターミナル出力を確認できることです。

チャットターミナルは、統合ターミナルのカラーテーマを採用し、ANSI カラーコントラストを向上させました。スクリーンリーダーユーザーは、出力にフォーカスがあるときにアクセシブルビュー `kb(editor.action.accessibleView)` を開いて、簡単に確認およびナビゲートできます。

詳細については、[チャットでのターミナルコマンドの使用](https://code.visualstudio.com/docs/copilot/chat/chat-tools#_terminal-commands) を参照してください。

### チャットターミナルでのコマンドステータスの詳細 {: #command-status-details-in-chat-terminals }

チャットターミナルメッセージは、コマンド装飾にカーソルを合わせると、コマンドの開始時間、期間、終了コードを表示するようになりました。

![エージェントによって npm install candy が実行されているターミナルのスクリーンショット。コマンド装飾のホバーには、コマンドの実行時間とステータスが表示されます。](https://code.visualstudio.com/assets/updates/1_107/terminal-command-exit.png)

### このセッションのすべてのターミナルコマンドを許可 {: #allow-all-terminal-commands-in-this-session }

セキュリティと制御を維持しながらチャットエクスペリエンスを最適化するために、ターミナルツールには、セッションのすべての将来のコマンドを許可する新しい自動承認オプションがあります。新しいセッションを開始すると、ターミナルコマンドは既存の承認構成に従います。

![チャットでターミナルコマンドを承認するときに、'Allow All Commands in this Session' オプションを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/terminal-allow-all.png)

### チャットターミナルアクションのキーボードショートカット {: #keyboard-shortcuts-for-chat-terminal-actions }

専用のキーボードショートカットを使用して、最新のチャットターミナルにフォーカス `kb(workbench.action.terminal.chat.focusMostRecentChatTerminal)` したり、展開状態を切り替えたり `kb(workbench.action.terminal.chat.focusMostRecentChatTerminalOutput)` できるようになりました。

### カスタムエージェントのキーボードショートカット {: #keyboard-shortcuts-for-custom-agents }

各カスタムエージェントには、コマンドリストに個別のアクションがあり、個別にキーボードショートカットをバインドできます。たとえば、「Code Reviewer」カスタムエージェントを定義した場合、キーボードショートカットをバインドするための **Chat: Open Chat (Code Reviewer Agent)** コマンドがコマンドパレットに表示されます。

![コマンドパレットのカスタムエージェントコマンドのスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/custom-agent-commands.png)

### Azure モデルプロバイダー: デフォルトの認証として Entra ID を使用 {: #azure-model-provider-entra-id-as-the-default-authentication }

**Setting**: `setting(github.copilot.chat.azureAuthType)`

デフォルトでは、Azure モデルプロバイダーは、Bring-Your-Own-Key (BYOK) モデルに接続するときに Entra ID 認証を使用するようになり、セキュリティが向上し、サインインエクスペリエンスが合理化されました。

API キーを使用して認証する場合は、`setting(github.copilot.chat.azureAuthType)` を `entraId` (デフォルト) ではなく `apiKey` に設定します。

### Anthropic モデル: 拡張思考のサポート {: #anthropic-models-extended-thinking-support }

**Setting**: `setting(github.copilot.chat.anthropic.thinking.budgetTokens)`

Anthropic モデルは、すべての Anthropic 拡張思考モデルでデフォルトで有効になっている拡張思考をサポートするようになりました。拡張思考は、応答を生成する前にステップバイステップの思考プロセスに追加のトークンを費やすことを可能にすることで、複雑なタスクに対する Claude の推論機能を強化し、より思慮深く正確な出力を導きます。

デフォルトの思考予算は 4,000 トークンに設定されています。`setting(github.copilot.chat.anthropic.thinking.budgetTokens)` 設定を変更して、モデルが拡張思考に使用できるトークン数を調整することで、この予算をカスタマイズできます。拡張思考を完全にオフにするには、予算を `0` に設定します。

> **Note**: ツール呼び出し間の推論を可能にするインターリーブ思考は、Bring-Your-Own-Key (BYOK) を介して Anthropic モデルを使用する場合にのみ使用できます。上記で構成された同じ思考予算設定を使用します。

### チャットビューの外観の改善 {: #chat-view-appearance-improvements }

読みやすさと使いやすさを向上させるために、チャットビューの外観にいくつかの改善を加えました:

* **Chat title**:

    チャットを開くと、上部に新しいタイトルコントロールが表示され、チャットのタイトルが表示されるだけでなく、空のチャットにすばやく戻ることができます。`setting(chat.viewTitle.enabled)` 設定でこの動作を構成します。

    <video src="https://code.visualstudio.com/assets/updates/1_107/chat-title.mp4" title="Video showing chat titles and returning back to the session list." autoplay loop controls muted></video>

* **Welcome banner**:

    新しいチャットを開くときにより最小限のエクスペリエンスを好む場合は、新しい設定 `setting(chat.viewWelcome.enabled)` を使用してアイコンとウェルカムテキストを非表示にできます。

    ![アイコンとウェルカムテキストが非表示になっている空のチャットビューのスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/chat-welcome.png)

* **Restore previous chat session**:

    再起動後または別のワークスペースを開いた後にチャットを開くと、前のセッションがデフォルトで復元されるようになりました。`setting(chat.viewRestorePreviousSession)` 設定でこの動作を変更し、常に空のチャットで開始することを選択できます。

### 機密ファイルへの編集の差分 {: #diffs-for-edits-to-sensitive-files }

チャットが `settings.json` や `package.json` などの機密ファイルを編集しようとすると、通知が表示され、変更が適用される前に承認を求められます。`setting(chat.tools.edits.autoApprove)` 設定で機密と見なされるファイルを構成できます。

以前は、モデルが提案した生の編集が表示されていましたが、理解するのが難しい場合がありました。現在、提案された変更の差分が表示され、編集の確認と承認が容易になりました。

![チャットでの package.json への提案された変更の差分を示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/sensitive-file-diff.png)

詳細については、[チャットでの機密ファイルの編集](https://code.visualstudio.com/docs/copilot/chat/review-code-edits#_edit-sensitive-files) を参照してください。

### 折りたたみ可能な推論とツール出力 (実験的) {: #collapsible-reasoning-and-tools-output-experimental }

**Setting**: `setting(chat.agent.thinkingStyle)`, `setting(chat.agent.thinking.collapsedTools)`

言語モデルの推論とエージェントツール出力により、チャットの会話はすぐに長くなり、追跡が難しくなる可能性があります。前回のイテレーションでは、`setting(chat.agent.thinkingStyle)` 設定を使用してチャットで思考トークンを表示する方法の改善にすでに取り組みました。

このイテレーションでは、ツール呼び出しなどの非推論チャット出力用の折りたたみ可能なチャットセクションを導入することで、チャットエクスペリエンスをさらに最適化しています。デフォルトでは、連続するツール呼び出しは、視覚的なノイズを減らすために折りたたまれるようになりました。

折りたたみ可能なアイテム (ほとんどのツールと推論テキスト) は要約され、AI によって生成されたタイトルが各折りたたみ可能なセクションに付けられます。

![折りたたみ可能なセクションに折りたたまれた複数のツール呼び出しを示すスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/collapsed-tools.png)

## MCP {: #mcp }

* 最新の MCP 仕様のサポートを追加しました ([詳細](#support-for-the-latest-mcp-specification))。
* 追加の設定なしで GitHub リモート MCP サーバーを使用 ([詳細](#github-mcp-server-provided-by-github-copilot-chat-preview))。

### 最新の MCP 仕様のサポート {: #support-for-the-latest-mcp-specification }

VS Code は、MCP 仕様の最新リビジョン `2025-11-25` をサポートしています。これには、特に以下が含まれます:

* [URL モードの抽出](https://modelcontextprotocol.io/specification/2025-11-25/client/elicitation#url-elicitation-requests)
* 長時間実行され、回復力のあるツール呼び出しとクライアント作業のための [タスク](https://modelcontextprotocol.io/specification/2025-11-25/basic/utilities/tasks)。
* 抽出における列挙型の選択肢の [強化](https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1330)

これらの改善は、`WWW-Authenticate` スコープの同意、クライアント ID メタデータドキュメント認証フロー、ツール、リソース、サーバーのアイコンなど、VS Code がすでにサポートしていた `2025-11-25` ドラフト機能に加えて提供されます。2025-11-25 ドラフトの変更ログは、[MCP Web サイト](https://modelcontextprotocol.io/specification/2025-11-25/changelog#major-changes) で確認できます。

詳細については、[VS Code での MCP サーバーの使用](https://code.visualstudio.com/docs/copilot/customization/mcp-servers) を参照してください。

### GitHub Copilot Chat が提供する GitHub MCP サーバー (プレビュー) {: #github-mcp-server-provided-by-github-copilot-chat-preview }

**Setting**: `setting(github.copilot.chat.githubMcpServer.enabled)`

GitHub リモート MCP サーバーは、GitHub Copilot Chat 拡張機能の組み込み MCP サーバーとして提供されるようになり、GitHub リポジトリおよびサービスとのシームレスな統合が提供されます。この統合には、いくつかの利点があります:

* すでに GitHub MCP サーバーを使用している Copilot CLI や Copilot Cloud Agent などの他の Copilot エージェントハーネスとの整合性
* 既存の GitHub 認証状態の再利用により、追加の認証プロンプトが不要になります
* GHE.com を含むさまざまな GitHub MCP エンドポイントの透過的なサポート

GitHub MCP サーバーを有効にするには、`setting(github.copilot.chat.githubMcpServer.enabled)` 設定を `true` に設定します。有効にすると、エージェントを使用するときにサーバーがツールピッカーに自動的に表示されます。これにより、追加の構成や設定なしで、GitHub の問題、プルリクエスト、その他のリポジトリ情報について質問できます。

GitHub MCP サーバーは、いくつかの設定によるカスタマイズをサポートしています:

* `setting(github.copilot.chat.githubMcpServer.toolsets)`: 使用可能なツールを構成します。デフォルトでは `default` ツールセットが使用されますが、[GitHub MCP サーバーのドキュメント](https://github.com/github/github-mcp-server/blob/main/docs/remote-server.md#remote-mcp-toolsets) に記載されているように、`workflows` やその他のツールセットを追加して拡張できます。**Note:** 特定のツールセットを追加すると、追加の権限が必要になる場合があり、再認証はまだサポートされていません。進行状況を追跡するには、[この GitHub の問題](https://github.com/microsoft/vscode/issues/280640) を参照してください。
* `setting(github.copilot.chat.githubMcpServer.readonly)`: サーバーに読み取り専用ツールのみを返すように強制し、書き込み操作を防ぎます。
* `setting(github.copilot.chat.githubMcpServer.lockdown)`: ツールの動作に対する追加のセキュリティ制御。

> **Note**: この機能は現在プレビュー段階であり、上記の設定による明示的なオプトインが必要です。将来のリリースでは、必要なときに利用でき、不要なときは邪魔にならない方法で、デフォルトで有効にする予定です。

## アクセシビリティ {: #accessibility }

### チャット確認のキーボード承認 {: #keyboard-approval-for-chat-confirmations }

エージェントが確認を求めたときに、`kb(workbench.action.chat.acceptTool)` を使用してキーボードで承認できるようになりました。

## エディターのエクスペリエンス {: #editor-experience }

* 開いているプロジェクトをより簡単に識別 ([詳細](#more-support-to-indicate-opened-windows-in-pickers))。
* macOS でスワイプしてナビゲート ([詳細](#macos-mouse-swipe-to-navigate))。
* ホバーポップアップを表示するタイミングを選択 ([詳細](#on-demand-editor-hover-popups))。

### ピッカーで開いているウィンドウを示すサポートの強化 {: #more-support-to-indicate-opened-windows-in-pickers }

ワークスペースがすでに VS Code ウィンドウで開いている場合のために、**Open Recent** ピッカーにインジケーターを追加しました。

![最近開いたワークスペースのスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/pickers.png)

現在アクティブなウィンドウは、他の開いているウィンドウとは少し異なって表示され、区別が明確になります。どのウィンドウでも開かれていないエントリにはアイコンがありません。

どのウィンドウがアクティブであるかを示すインジケーターは、ウィンドウピッカーにも適用されています。

### macOS: マウススワイプによるナビゲート {: #macos-mouse-swipe-to-navigate }

**Setting**: `setting(workbench.editor.swipeToNavigate)`

macOS では、トラックパッドで 3 本指のスワイプジェスチャを使用してエディター間を移動できるようになりました。左または右にスワイプすると、任意のエディターグループ内の最近使用したエディター間を移動します。`setting(workbench.editor.swipeToNavigate)` 設定でこれを有効にします。

> **Note**: 現在、3 本指のスワイプジェスチャのみをサポートしています。これが機能するように、スワイプのトラックパッド設定が次のように構成されていることを確認してください:
>
> * ページ間をスワイプ: 3 本指で左または右にスクロールします。
> * フルスクリーンアプリ間をスワイプ: 4 本指で左または右にスワイプします。

### オンデマンドのエディターホバーポップアップ {: #on-demand-editor-hover-popups }

**Setting**: `setting(editor.hover.enabled)`

エディターでの自動ホバーポップアップを無効にしつつ、キーボード修飾子を使用してオンデマンドでホバー情報をトリガーする機能を維持できるようになりました。`setting(editor.hover.enabled)` 設定は、`on`、`off`、および `onKeyboardModifier` の 3 つの値をサポートするようになりました。

`onKeyboardModifier` に設定すると、コードにカーソルを合わせているときに `setting(editor.multiCursorModifier)` 設定とは逆の修飾キーを押している場合にのみ、ホバー情報が表示されます。これにより、テキスト選択中の視覚的な気晴らしが軽減され、必要に応じてコンテキスト情報にすばやくアクセスできます。

たとえば、`setting(editor.multiCursorModifier)` が `ctrlCmd` に設定されている場合、ホバー中に `kbstyle(Alt)` を押すとホバーが表示されます。`alt` に設定されている場合、`kbstyle(Ctrl)` (または macOS では `kbstyle(Cmd)`) を押すとホバーが表示されます。

## コード編集 {: #code-editing }

* TypeScript が名前変更の提案を提供 ([詳細](#rename-suggestions-for-typescript))。
* 次の編集提案に新しいモデルを使用 ([詳細](#new-model-for-next-edit-suggestions))。
* ビューポート外の次の編集提案をプレビュー ([詳細](#preview-next-edit-suggestions-outside-the-viewport))。

### TypeScript の名前変更の提案 {: #rename-suggestions-for-typescript }

名前変更の提案は、通常のテキスト提案の代わりにシンボルの名前変更を行うべきタイミングを予測します。予測されると、通常のテキスト編集と一緒に追加のインジケーターが表示されます。その後、`kbstyle(Shift+Tab)` を使用してシンボルの名前変更を適用できます。

次のビデオでは、プロパティ `a` の名前が `width` に変更されています。名前変更の提案は、`b` の名前を `height` に変更すること、および 2 つのパラメーター `a` と `b` の名前をそれに応じて変更することを提案します。次の名前変更の提案は、他のシンボルへの関連する名前変更を予測する場合に最適に機能します。

<video src="https://code.visualstudio.com/assets/updates/1_107/next-rename-suggestion.mp4" title="Video showing next rename suggestion in the editor." autoplay loop controls muted></video>

> **Note**: この機能は現在、実験を使用してユーザーベースにロールアウトされており、今のところ TypeScript でのみ使用できます。他のプログラミング言語のサポートも計画されています。

### 次の編集提案のための新しいモデル {: #new-model-for-next-edit-suggestions }

よりスマートで、最新の編集に合わせた次の編集提案のための新しいモデルをリリースしました。これにより、受け入れと却下のパフォーマンスが大幅に向上します。詳細については、GitHub ブログ投稿の [モデルとその開発](https://github.blog/ai-and-ml/github-copilot/evolving-github-copilots-next-edit-suggestions-through-custom-model-training/#h-continuous-improvements-nbsp) を参照してください。

### ビューポート外の次の編集提案のプレビュー {: #preview-next-edit-suggestions-outside-the-viewport }

現在のビューポートの外にある次の編集提案を受け取った場合、現在の位置からスクロールせずに提案内容を知ることは困難な場合があります。カーソルが現在ある場所に次の編集提案のプレビューをレンダリングすることで、このエクスペリエンスを改善しました。これにより、提案を確認する際のフローへの影響を軽減できます。

<video src="https://code.visualstudio.com/assets/updates/1_107/nes-outside-viewport.mp4" title="Video of next edit suggestion preview." autoplay loop controls muted></video>

> **Note**: 現在の言語モデルは、カーソルの近くにある次の編集提案に焦点を当てているため、ビューポートの外にある提案はあまり表示されない場合があります。ただし、はるか遠くにある提案を提供できるモデルの開発に積極的に取り組んでいます！

詳細については、[VS Code でのインライン提案](https://code.visualstudio.com/docs/copilot/ai-powered-suggestions) を参照してください。

## ソース管理 {: #source-control }

### ソース管理リポジトリビューでのスタッシュ (実験的) {: #stashes-in-the-source-control-repositories-view-experimental }

**Settings**: `setting(scm.repositories.explorer:true)`, `setting(scm.repositories.selectionMode:single)`

このマイルストーンでは、Stashes ノードを追加することで、Source Control Repositories ビューに表示されるリポジトリアーティファクトのリストを引き続き拡張しました。このノードの下で、スタッシュの完全なリストを表示し、各スタッシュを表示、適用、およびポップできます。コンテキストメニューには、各スタッシュを削除するアクションも含まれています。

![Stashes ノードとそのコンテキストメニューを示す Source Control Repositories ビューのスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/stashes-repo-explorer.png)

`setting(scm.repositories.selectionMode:single)` および `setting(scm.repositories.explorer:true)` 設定を設定することで、実験的なリポジトリエクスプローラーを有効にできます。ぜひ試してみて、リポジトリエクスプローラーで他にどのようなリポジトリアーティファクトを見たいかをお知らせください。

詳細については、[VS Code でのソース管理の使用](https://code.visualstudio.com/docs/sourcecontrol/overview) を参照してください。

## デバッグ {: #debugging }

### チャットへの変数の添付 {: #attach-variables-to-chat }

VS Code のチャットコンテキストに変数を添付できるようになりました。これを行うには、**Variables** および **Watch** ビューでデータを右クリックするか、チャットの **Add Context** ボタンを使用します。

## ターミナル {: #terminal }

### ターミナルの提案が安定版にロールアウト {: #terminal-suggest-rolled-out-to-stable }

Terminal Suggest が安定版ユーザー向けに有効になり、シェルコマンドの入力中にインライン補完とコンテキストヒントが提供されるようになりました。提案では、関連する引数値がグループ化されるようになったため、オプションフラグとそのパラメーターがリスト内で整理された状態になります。

## 認証 {: #authentication }

### Microsoft 認証のクロスプラットフォームネイティブブローカーサポート {: #crossplatform-native-broker-support-for-microsoft-authentication }

**Setting**: `setting(microsoft-authentication.implementation)`

このマイルストーンでは、最新の MSAL ライブラリを採用し、以下でネイティブエクスペリエンスを通じてサインインできるようになりました:

* Intel Mac
* Linux x64 (Debian ベースの特定のディストリビューションのみ)

![VS Code へのサインインを求めるネイティブブローカーダイアログウィンドウのスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/macOS-auth-broker.png)

これは、以下の既存のサポートに加えて提供されます:

* Windows x64
* macOS M シリーズ (ARM)

macOS および Linux のサポートには、マシンが Intune に登録されており、ネイティブブローカーの使用にオプトインしている必要があります。

これにより、優れたシングルサインオンフローが可能になり、Microsoft 認証セッションを取得するための推奨される方法となります。MSAL チームは、残りのプラットフォーム (Windows ARM、Linux ARM、および追加のディストリビューション) についても時間をかけてこれを有効にする予定ですので、ご期待ください！

> NOTE: ブローカー経由での認証に問題がある場合は、`setting(microsoft-authentication.implementation)` を `msal-no-broker` に変更して、代わりにブラウザーを使用して認証することができます。

### `classic` Microsoft 認証が利用不可に {: #classic-microsoft-authentication-no-longer-available }

先月述べたように、使用率が低く、Entra ID チームによって推奨されていないため、`setting(microsoft-authentication.implementation)` の `classic` オプションを削除しました。

リマインダー: `setting(microsoft-authentication.implementation)` 設定は、問題が発生した場合にユーザーが Microsoft アカウントのネイティブブローカー認証をオプトアウトできるようにするために存在していました。この設定の値は次のとおりです:

* `msal` - 利用可能な場合はブローカー認証で MSAL を使用します (デフォルト)
* `msal-no-broker` - ブローカー認証なしで MSAL を使用します 

## 言語 {: #languages }

### TypeScript 7.0 プレビュー {: #typescript-70-preview }

[次期 TypeScript 7 リリース](https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/) に対する VS Code のサポートを改善するために、TypeScript チームと引き続き協力しました。TypeScript 7 はネイティブコードで完全に書き直されており、パフォーマンスが劇的に向上しています。

TypeScript 7 プレビューでは、ほぼ完全な型チェックがサポートされており、TypeScript チームはエディター機能の追加にも取り組んでいます。最近のハイライトには、自動インポート補完、名前変更のサポート、参照コードレンズなどがあります。

[`TypeScript (Native Preview)` 拡張機能](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.native-preview) をインストールすることで、今日から TypeScript 7.0 を試すことができます。次に、JavaScript または TypeScript ファイルで `TypeScript (Native Preview): Enable (Experimental)` コマンドを実行して、すべての IntelliSense をネイティブプレビューを使用するように切り替えます。TypeScript 7 の完全なアップデートと TypeScript プロジェクトの一般的な方向性については、[最新の TypeScript 7 ブログ投稿](https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/) を確認してください。

TypeScript 7 の VS Code サポートを改善するために、TypeScript チームと引き続き緊密に連携する予定です。TypeScript 7 の準備ができたら、VS Code の JavaScript および TypeScript IntelliSense を強化するデフォルトのエクスペリエンスとして切り替えるという長期的な計画があります。古い TS バージョンを使用する必要がある場合、または TypeScript 7 に簡単に移植できない TypeScript サービスプラグインなどのエディター機能が必要な場合は、TypeScript 7.0+ と並行して、当面の間、既存の TypeScript バージョンのサポートを継続する予定です。

## リモート開発 {: #remote-development }

[Remote Development 拡張機能](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack) を使用すると、[Dev Container](https://code.visualstudio.com/docs/devcontainers/containers)、SSH 経由のリモートマシン、または [Remote Tunnels](https://code.visualstudio.com/docs/remote/tunnels)、または [Windows Subsystem for Linux](https://learn.microsoft.com/windows/wsl) (WSL) をフル機能の開発環境として使用できます。

ハイライトは次のとおりです:

* SSH 再接続猶予時間の制御

これらの機能の詳細については、[Remote Development リリースノート](https://github.com/microsoft/vscode-docs/blob/main/remote-release-notes/v1_107.md) を参照してください。

## エンタープライズ {: #enterprise }

VS Code の [エンタープライズ機能](https://code.visualstudio.com/docs/setup/enterprise) の詳細については、ドキュメントを参照してください。

### エージェントツールの自動承認の制御 {: #control-auto-approval-for-agent-tools }

**Setting**: `setting(chat.tools.eligibleForAutoApproval)`

特定のエージェントツールは、明示的なユーザー承認なしに使用するとリスクが生じる可能性があります。特に、破壊的なアクションを実行したり、機密データにアクセスしたり、バックグラウンドで任意のコードを実行したりできるツール (たとえば、`runTask`) はそうです。

新しい `setting(chat.tools.eligibleForAutoApproval)` 設定を使用して、自動承認の対象となるツールを定義できるようになりました。ツールが自動承認から拒否された場合、ユーザーはチャットでこのツールを常に承認するオプションを持たず、使用ごとに明示的に承認する必要があります。

組織は、エージェントを使用する際のセキュリティを強化するために、ユーザー全体にエンタープライズポリシーを介してこの動作を強制できます。

### ポリシーによるエージェントの使用の無効化 {: #disable-the-use-of-agents-by-policy }

エンタープライズポリシーによってチャットでのエージェントの使用が無効になっている場合、エージェントピッカーは、それらが利用できない理由をより適切に伝えるようになりました。

![エンタープライズポリシーによりエージェントモードが利用できないことを示すエージェントピッカーのスクリーンショット。](https://code.visualstudio.com/assets/updates/1_107/agent-mode-disabled-by-policy.png)

### Codespaces での GitHub Enterprise ポリシーのサポート {: #support-github-enterprise-policies-in-codespaces }

VS Code に適用されるエンタープライズまたは組織のポリシーを GitHub で指定できます。たとえば、組織の開発者が使用する [MCP レジストリ URL を構成](https://docs.github.com/en/copilot/how-tos/administer-copilot/manage-mcp-usage/configure-mcp-registry) できます。

このリリースでは、GitHub Codespaces で VS Code を使用する場合のこれらのポリシーのサポートを追加しました。開発者が Codespace を開くと、VS Code をローカルで使用する場合と同様に、同じポリシーが自動的に適用されます。

## 拡張機能への貢献 {: #contributions-to-extensions }

### GitHub プルリクエスト {: #github-pull-requests }

プルリクエストと問題の作業、作成、管理を可能にする [GitHub Pull Requests](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github) 拡張機能の進歩がさらに進んでいます。新機能は次のとおりです:

* プルリクエストまたは問題の Webビューがアクティブな場合のプルリクエストと問題の暗黙的なコンテキスト。
* プルリクエストと問題は、"Add Context" を介してチャットセッションにコンテキストとして明示的に追加できます。
* Copilot プルリクエストは、ボタン 1 つでレビューの準備完了、承認、自動マージの設定としてマークできます。

リリースのすべてについて知るには、拡張機能の [0.124.0 の変更ログ](https://github.com/microsoft/vscode-pull-request-github/blob/main/CHANGELOG.md#01240) を確認してください。

## 提案された API {: #proposed-apis }

### 寄稿されたチャットコンテキスト {: #contributed-chat-context }

拡張機能がチャットのコンテキストプロバイダーを提供できるようにする新しい API 提案があります。これにより、拡張機能は独自のドメインからリッチなコンテキストを提供して、チャットセッションで使用できるようになります。たとえば、GitHub Pull Request 拡張機能は次のコンテキストを提供します:

* 現在のリポジトリ、ブランチ、プルリクエストに関する情報を含むワークスペースコンテキスト。
* プルリクエストまたは問題の Webビューがアクティブな場合の暗黙的なプルリクエストと問題のコンテキスト。
* ユーザーが "Add Context" を介して追加した場合の明示的なプルリクエストと問題のコンテキスト。

API はまだ初期段階にあるため、変更が予想されます。提案のどの部分が拡張機能作成者のニーズを解決するかについてのフィードバックをお待ちしています。提案はこちらにあります: [vscode.proposed.chatContextProvider.d.ts](https://github.com/microsoft/vscode/blob/615abcc4ae680ef1950fe607c3b3532d3ee0a576/src/vscode-dts/vscode.proposed.chatContextProvider.d.ts)。

## エンジニアリング {: #engineering }

### ビルドのロールアウト {: #builds-rollout }

Insiders ビルドリリースの 4 時間の時間枠での段階的なロールアウトを開始しました。つまり、Insiders ユーザーとして、通常よりも少し遅れて更新通知を受け取る可能性があります。急いでいる場合は、いつでも **Check for Updates** を実行して、更新を強制的に適用できます。

November 2025 (1.107) リリースを 24 時間の時間枠で Stable ユーザーにロールアウトします。Insiders と同様に、いつでも **Check for Updates** を実行して、更新を強制的に適用できます。

### Web サイトの検索機能の改善 {: #improved-website-search-functionality }

ドキュメント全体を簡単かつ迅速にナビゲートできる高速なクライアント側検索により、[Web サイト](https://code.visualstudio.com) を改善しました。

<video src="https://code.visualstudio.com/assets/updates/1_107/website-search.mp4" title="ドロップダウンリストに検索結果の提案が表示される Web サイトの検索機能を示すビデオ。" autoplay loop controls muted></video>

この機能の背後にあるライブラリをオープンソース化しました: [docfind](https://github.com/microsoft/docfind) をダウンロードして、今すぐプロジェクトに使用できます！この技術の背後にあるイノベーションに関するブログ投稿をフォローアップします。

### TypeScript として直接実行されるように更新されたビルドスクリプト {: #updated-build-scripts-run-directly-as-typescript }

このイテレーションでは、ビルドスクリプトをクリーンアップして、作業と保守を容易にしました。これらのビルドスクリプトは、コンパイルされた TypeScript、`ts-node` を使用して実行される TypeScript ファイル、および JavaScript が混在していました。これらのスクリプトの多くは型チェックされておらず、`import` と `export` を使用した最新のモジュールではなく commonjs (`require`) を使用していました。さらに悪いことに、TypeScript ビルドスクリプトの多くは、コンパイルされた JS 出力をソース管理にチェックインする必要がありました。なんてこった！

ありがたいことに、Node 22.18+ では [スクリプトを TypeScript として直接実行](https://nodejs.org/en/learn/typescript/run-natively) できるようになりました。これにより、ビルドスクリプトを最新の TypeScript に段階的に変換できます。新しい TypeScript コードを Node で直接実行できるように、次の tsconfig オプションを使用しました:

```json
{
  "compilerOptions": {
     "target": "esnext",
     "module": "nodenext",
     "noEmit": true, // .js ファイルを生成しない
     "erasableSyntaxOnly": true, // Node が削除できる TypeScript 構文のみを許可。たとえば、Enum や名前空間は許可されません
     "allowImportingTsExtensions": true, // .ts ファイルのインポートを許可
     "verbatimModuleSyntax": true // スクリプトが Node によって直接実行されるときに、インポートが有効であることを確認
  }
}
```

GitHub Copilot は、古い commonjs ファイルをモジュールに変換したり、型注釈を追加したりするなど、必要な変更の多くを自動化するのに役立ちました。

心に留めておくべきことの 1 つは、Node は TypeScript コードを実行できますが、実際には型チェックを行わないということです。そのためには、依然として `tsc` を使用する必要があります。vscode の場合、実際には [`ts-go`](https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/) を使用しており、すべてのビルドスクリプトを 1 秒未満で完全に型チェックできます。

`node build/hygiene.ts` を直接実行できるのは非常に素晴らしいことです。TypeScript に完全に切り替えることで、ビルドスクリプトを最新化し、タイプセーフをもたらすことができ、理解と変更がはるかに簡単になります。さらに、以前はチェックインしておく必要があった約 15,000 行のコンパイル済み JS コードを削除できました！

### Copilot 拡張機能の統合 {: #copilot-extensions-unification }

**Setting**: `setting(chat.extensionUnification.enabled)`

インライン提案が GitHub Copilot Chat 拡張機能から提供されるように完全にロールアウトしました。この変更の一環として、GitHub Copilot 拡張機能はすべてのユーザーに対してデフォルトで無効になります。

インライン提案で問題が発生した場合は、報告してください。`setting(chat.extensionUnification.enabled)` を `false` に設定することで、一時的に以前の動作に戻すことができます。これにより、GitHub Copilot 拡張機能が再度有効になります。

2026 年 1 月に GitHub Copilot 拡張機能を完全に廃止する予定であり、その時点で `setting(chat.extensionUnification.enabled)` 設定も削除されることに注意してください。

## 注目すべき修正 {: #notable-fixes }

* [vscode#233635](https://github.com/microsoft/vscode/issues/233635) - 他のウィンドウを閉じるアクションを追加
* [vscode#262817](https://github.com/microsoft/vscode/issues/262817) - 左端のグループから "Move Editor into Previous Group" を実行すると、左側に新しいグループが作成されるはずです
* [vscode#264569](https://github.com/microsoft/vscode/issues/264569) - window.activeBorder の色を設定および削除しても、ウィンドウの境界線の色がリセットされない
* [vscode#140186](https://github.com/microsoft/vscode/issues/140186) - リモートコンテナーがワークスペースとして開かれているときにローカルターミナルを開くことができない
* [vscode#228359](https://github.com/microsoft/vscode/issues/228359) - ターミナルを再起動すると、ターミナルが閉じてしまうことがよくある
* [vscode#232420](https://github.com/microsoft/vscode/issues/232420) - Python3.13 でターミナルカーソルが間違った場所にある
* [vscode#247568](https://github.com/microsoft/vscode/issues/247568) - ファイル名にコロンが含まれるファイルでターミナル Ctrl+Click を実行してもファイルが開かず、先行するゼロが削除される
* [vscode#275011](https://github.com/microsoft/vscode/issues/275011) - 信頼されたワークスペース上の WSL で VS Code を開くと、奇妙なターミナルメッセージが表示される
* [vscode#275417](https://github.com/microsoft/vscode/issues/275417) - reveal:never, close:true のタスクが WSL で機能しなくなった
* [vscode#277311](https://github.com/microsoft/vscode/issues/277311) - コマンドパレットの「最近使用した」リストからコマンドを削除する "X" ボタンを追加
* [vscode#282222](https://github.com/microsoft/vscode/issues/282222) - SCM - git blame/timeline/graph ホバーレンダリングを改善。Stanislav Fort (Aisle Research) に感謝します
* [vscode-python-environments#1000](https://github.com/microsoft/vscode-python-environments/issues/1000) - 環境のアクティブ化が "Command Prompt" で確実に機能しない

## ありがとう {: #thank-you }

### 問題追跡 {: #issue-tracking }

問題追跡への貢献:

* [@gjsjohnmurray (John Murray)](https://github.com/gjsjohnmurray)
* [@RedCMD (RedCMD)](https://github.com/RedCMD)
* [@tamuratak (Takashi Tamura)](https://github.com/tamuratak)
* [@IllusionMH (Andrii Dieiev)](https://github.com/IllusionMH)
* [@albertosantini (Alberto Santini)](https://github.com/albertosantini)

`vscode` への貢献:

* [@Abrifq (Arda Aydın)](https://github.com/Abrifq)
  * バッククォートが含まれている場合にターミナルタブのプロンプト入力が壊れる問題を修正 [PR #272425](https://github.com/microsoft/vscode/pull/272425)
  * microsoft#272425 のクリーンアップ [PR #277406](https://github.com/microsoft/vscode/pull/277406)
* [@bilogic](https://github.com/bilogic): `// #region ...` も有効なマーカーとして認識するように変更 [PR #278943](https://github.com/microsoft/vscode/pull/278943)
* [@busorgin (Artem Busorgin)](https://github.com/busorgin): VSBuffer で TextDecoder.ignoreBOM を true に設定 [PR #272389](https://github.com/microsoft/vscode/pull/272389)
* [@cannona (Aaron Cannon)](https://github.com/cannona): "Move Editor into Previous Group" で新しいグループを作成できるように変更 [PR #275968](https://github.com/microsoft/vscode/pull/275968)
* [@DrSergei (Sergei Druzhkov)](https://github.com/DrSergei): ブレークポイントの範囲計算を修正 [PR #280263](https://github.com/microsoft/vscode/pull/280263)
* [@gjsjohnmurray (John Murray)](https://github.com/gjsjohnmurray): 一部の設定における「ステータスバー」という用語の非標準的な大文字表記を修正 (#277376 を修正) [PR #277383](https://github.com/microsoft/vscode/pull/277383)
* [@jakebailey (Jake Bailey)](https://github.com/jakebailey): `@types/vscode` の package.json も更新 [PR #277972](https://github.com/microsoft/vscode/pull/277972)
* [@JeffreyCA](https://github.com/JeffreyCA): ターミナルの提案 - 提案に永続的なオプションを含め、提案のグループ化を改善 [PR #276409](https://github.com/microsoft/vscode/pull/276409)
* [@joelverhagen (Joel Verhagen)](https://github.com/joelverhagen): NuGet MCP インストールからのランタイム構成を期待するように変更 [PR #271770](https://github.com/microsoft/vscode/pull/271770)
* [@Josbleuet (Eric Fortin)](https://github.com/Josbleuet): 動的認証プロバイダーのロガーファイル名に含まれる不正な文字を修正 [PR #280217](https://github.com/microsoft/vscode/pull/280217)
* [@nikdmello (Nik D'Mello)](https://github.com/nikdmello): KaTeX マッチングにおける jQuery 式の katex 正規表現を更新 [PR #269635](https://github.com/microsoft/vscode/pull/269635)
* [@ramanverse (Raman)](https://github.com/ramanverse): 廃止された maybeMigrateCurrentSession メソッドを削除 [PR #280042](https://github.com/microsoft/vscode/pull/280042)
* [@remcohaszing (Remco Haszing)](https://github.com/remcohaszing): Cursor mdc ファイルを markdown としてマーク [PR #276518](https://github.com/microsoft/vscode/pull/276518)
* [@SalerSimo](https://github.com/SalerSimo): 設定のブール値ウィジェットのオブジェクトオーバーフローを修正 [PR #278884](https://github.com/microsoft/vscode/pull/278884)
* [@SimonSiefke (Simon Siefke)](https://github.com/SimonSiefke)
  * 修正: breadcrumbs のメモリリーク [PR #276597](https://github.com/microsoft/vscode/pull/276597)
  * 修正: quick diff モデルのメモリリーク [PR #276914](https://github.com/microsoft/vscode/pull/276914)
  * 修正: breadcrumbs のメモリリーク [PR #276915](https://github.com/microsoft/vscode/pull/276915)
  * 修正: ターミナルプロセスのメモリリーク (部分的) [PR #276962](https://github.com/microsoft/vscode/pull/276962)
  * 修正: スタートアップページのメモリリーク [PR #277199](https://github.com/microsoft/vscode/pull/277199)
  * 修正: ターミナルタブリストのメモリリーク [PR #277225](https://github.com/microsoft/vscode/pull/277225)
  * 修正: サブデコレーションが破棄されないことによるメモリリークの可能性 [PR #278328](https://github.com/microsoft/vscode/pull/278328)
  * 修正: デコレーション登録によるメモリリークの可能性 [PR #278331](https://github.com/microsoft/vscode/pull/278331)
  * 修正: タスク問題モニターのメモリリーク [PR #279093](https://github.com/microsoft/vscode/pull/279093)
  * 修正: 履歴サービスのメモリリーク [PR #279246](https://github.com/microsoft/vscode/pull/279246)
  * 修正: 複合バーのメモリリーク [PR #280659](https://github.com/microsoft/vscode/pull/280659)
* [@tamuratak (Takashi Tamura)](https://github.com/tamuratak)
  * コードブロックエディターのレンダリング完了後に onDidChangeHeight を発行するように変更。#265031 を修正 [PR #274691](https://github.com/microsoft/vscode/pull/274691)
  * 修正: markdown レンダリングの DOM.reset で children の代わりに childNodes を使用するように変更。#266103 を修正 [PR #276890](https://github.com/microsoft/vscode/pull/276890)
  * 修正: $(a+b)^2$ を正しく処理するように mathInlineRegExp を更新 [PR #280021](https://github.com/microsoft/vscode/pull/280021)
* [@yavanosta (Dmitry Guketlev)](https://github.com/yavanosta): UriIdentityService のパフォーマンスを向上 (#273108) [PR #273111](https://github.com/microsoft/vscode/pull/273111)
* [@yaxiaoliu](https://github.com/yaxiaoliu): 修正(process-explorer): 名前正規表現のエラー [PR #280273](https://github.com/microsoft/vscode/pull/280273)

`vscode-copilot-chat` への貢献:

* [@AbdelrahmanAbouelenin (ababouelenin)](https://github.com/AbdelrahmanAbouelenin)
  * VSC hidden family を追加 [PR #1996](https://github.com/microsoft/vscode-copilot-chat/pull/1996)
  * ハッシュの統合 [PR #2181](https://github.com/microsoft/vscode-copilot-chat/pull/2181)
  * VSC モデル C の文字列置換ツールを有効化 [PR #2344](https://github.com/microsoft/vscode-copilot-chat/pull/2344)
* [@cuining](https://github.com/cuining): ハードコードされた制限付きインポートリストの代わりに Node の組み込みモジュールを使用するように ESLint 構成を更新 [PR #2107](https://github.com/microsoft/vscode-copilot-chat/pull/2107)
* [@IanMatthewHuff (Ian Huff)](https://github.com/IanMatthewHuff)
  * nullWorkspaceFileIndex の any 型を修正 [PR #1964](https://github.com/microsoft/vscode-copilot-chat/pull/1964)
  * GitDiffService の修正 [PR #2116](https://github.com/microsoft/vscode-copilot-chat/pull/2116)
* [@jeffreyhunter77 (Jeff Hunter)](https://github.com/jeffreyhunter77)
  * @vscode/chat-lib のインライン補完 [PR #2131](https://github.com/microsoft/vscode-copilot-chat/pull/2131)
  * @vscode/chat-lib のインストールスクリプトとパッケージを修正 [PR #2134](https://github.com/microsoft/vscode-copilot-chat/pull/2134)
  * chat-lib の補完で capi クライアントをオプションに変更 [PR #2369](https://github.com/microsoft/vscode-copilot-chat/pull/2369)
  * 補完のフォールバックモデル ID を更新 [PR #2370](https://github.com/microsoft/vscode-copilot-chat/pull/2370)
* [@joelverhagen (Joel Verhagen)](https://github.com/joelverhagen): server.json のフォーマットを VS Code コアから分離 [PR #1373](https://github.com/microsoft/vscode-copilot-chat/pull/1373)

`vscode-js-debug` への貢献:

* [@marat-gainullin](https://github.com/marat-gainullin): さまざまな場所での undefined のデリファレンスを修正 [PR #2297](https://github.com/microsoft/vscode-js-debug/pull/2297)

`vscode-pull-request-github` への貢献:

* [@vicky1999 (Vignesh)](https://github.com/vicky1999)
  * 修正: 狭いエディターペインでのメッセージの折り返し [PR #8121](https://github.com/microsoft/vscode-pull-request-github/pull/8121)
  * 機能: 各コミットのコミットステータスアイコンを表示 [PR #8142](https://github.com/microsoft/vscode-pull-request-github/pull/8142)
  * 機能: PR 概要にコメントリンクのコピーボタンを追加 [PR #8150](https://github.com/microsoft/vscode-pull-request-github/pull/8150)

`vscode-python` への貢献:

* [@iBug](https://github.com/iBug): [microsoft/vscode#232420](https://github.com/microsoft/vscode/issues/232420) を修正: Python REPL カーソルのドリフト [PR #25521](https://github.com/microsoft/vscode-python/pull/25521)

`vscode-python-debugger` への貢献:

* [@rchiodo (Rich Chiodo)](https://github.com/rchiodo): 最新の debugpy に更新 [PR #877](https://github.com/microsoft/vscode-python-debugger/pull/877)

`vscode-python-environments` への貢献:

* [@zsol (Zsolt Dollenstein)](https://github.com/zsol): UvWorkspace 環境もサポート [PR #1022](https://github.com/microsoft/vscode-python-environments/pull/1022)

`language-server-protocol` への貢献:

* [@arshadrr (Arshad Riyaz)](https://github.com/arshadrr): slang-server を追加 [PR #2200](https://github.com/microsoft/language-server-protocol/pull/2200)

`node-native-keymap` への貢献:

* [@tmm1 (Aman Karmani)](https://github.com/tmm1): msctf.h ヘッダーの大文字小文字を修正 [PR #64](https://github.com/microsoft/node-native-keymap/pull/64)
* [@yonas (Yonas Yanfa)](https://github.com/yonas): README.md を更新 - FreeBSD での依存関係として libxkbfile を追加 [PR #61](https://github.com/microsoft/node-native-keymap/pull/61)

`node-pty` への貢献:

* [@42lizard (Oliver Gassner)](https://github.com/42lizard): termios と util の OpenBSD インクルードを追加 [PR #817](https://github.com/microsoft/node-pty/pull/817)
* [@huangcs427 (huangcs)](https://github.com/huangcs427): "Enjoy Git" の実世界での使用例を追加 [PR #818](https://github.com/microsoft/node-pty/pull/818)

`python-environment-tools` への貢献:

* [@reflectronic (John Tur)](https://github.com/reflectronic): Windows でコンソールウィンドウを作成せずにコマンドを実行するように変更 [PR #266](https://github.com/microsoft/python-environment-tools/pull/266)
* [@zsol (Zsolt Dollenstein)](https://github.com/zsol): uv ワークスペースを検出するように変更 [PR #263](https://github.com/microsoft/python-environment-tools/pull/263)

---

<a id="scroll-to-top" role="button" title="Scroll to top" aria-label="scroll to top" href="#"><span class="icon"></span></a>
<link rel="stylesheet" type="text/css" href="css/inproduct_releasenotes.css"/>
